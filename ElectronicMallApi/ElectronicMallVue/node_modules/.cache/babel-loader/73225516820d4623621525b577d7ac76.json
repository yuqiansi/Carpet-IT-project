{"ast":null,"code":"import \"core-js/modules/es.number.to-fixed.js\";\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport * as numberUtil from '../../util/number.js';\nimport { isDimensionStacked } from '../../data/helper/dataStackHelper.js';\nimport { indexOf, curry, clone, isArray } from 'zrender/lib/core/util.js';\nimport { parseDataValue } from '../../data/helper/dataValueHelper.js';\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n}\n\nfunction markerTypeCalculatorWithExtent(markerType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var stacked = isDimensionStacked(data, targetDataDim\n  /* , otherDataDim */\n  );\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n  var value = numCalculate(data, calcDataDim, markerType);\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);\n  var coordArrValue = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.\n\n  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return [coordArr, coordArrValue];\n} // TODO Specified percent\n\n\nvar markerTypeCalculator = {\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n  average: curry(markerTypeCalculatorWithExtent, 'average'),\n  median: curry(markerTypeCalculatorWithExtent, 'median')\n};\n/**\r\n * Transform markPoint data item to format used in List by do the following\r\n * 1. Calculate statistic like `max`, `min`, `average`\r\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\r\n */\n\nexport function dataTransform(seriesModel, item) {\n  if (!item) {\n    return;\n  }\n\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem;\n  var dims = coordSys && coordSys.dimensions; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (!hasXAndY(item) && !isArray(item.coord) && isArray(dims)) {\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);\n      item.coord = coordInfo[0]; // Force to use the value of calculated value.\n      // let item use the value without stack.\n\n      item.value = coordInfo[1];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      item.coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];\n    }\n  } // x y is provided\n\n\n  if (item.coord == null || !isArray(dims)) {\n    item.coord = [];\n  } else {\n    // Each coord support max, min, average\n    var coord = item.coord;\n\n    for (var i = 0; i < 2; i++) {\n      if (markerTypeCalculator[coord[i]]) {\n        coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n      }\n    }\n  }\n\n  return item;\n}\nexport function getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n  }\n\n  return ret;\n}\n\nfunction dataDimToCoordDim(seriesModel, dataDim) {\n  var dimItem = seriesModel.getData().getDimensionInfo(dataDim);\n  return dimItem && dimItem.coordDim;\n}\n/**\r\n * Filter data which is out of coordinateSystem range\r\n * [dataFilter description]\r\n */\n\n\nexport function dataFilter( // Currently only polar and cartesian has containData.\ncoordSys, item) {\n  // Always return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\nexport function zoneFilter( // Currently only polar and cartesian has containData.\ncoordSys, item1, item2) {\n  // Always return true if there is no coordSys\n  return coordSys && coordSys.containZone && item1.coord && item2.coord && !hasXOrY(item1) && !hasXOrY(item2) ? coordSys.containZone(item1.coord, item2.coord) : true;\n}\nexport function createMarkerDimValueGetter(inCoordSys, dims) {\n  return inCoordSys ? function (item, dimName, dataIndex, dimIndex) {\n    var rawVal = dimIndex < 2 // x, y, radius, angle\n    ? item.coord && item.coord[dimIndex] : item.value;\n    return parseDataValue(rawVal, dims[dimIndex]);\n  } : function (item, dimName, dataIndex, dimIndex) {\n    return parseDataValue(item.value, dims[dimIndex]);\n  };\n}\nexport function numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum_1 = 0;\n    var count_1 = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum_1 += val;\n        count_1++;\n      }\n    });\n    return sum_1 / count_1;\n  } else if (type === 'median') {\n    return data.getMedian(valueDataDim);\n  } else {\n    // max & min\n    return data.getDataExtent(valueDataDim)[type === 'max' ? 1 : 0];\n  }\n}","map":{"version":3,"sources":["D:/GitHub repository/Carpet-IT-project/ElectronicMallApi/ElectronicMallVue/node_modules/echarts/lib/component/marker/markerHelper.js"],"names":["numberUtil","isDimensionStacked","indexOf","curry","clone","isArray","parseDataValue","hasXOrY","item","isNaN","parseFloat","x","y","hasXAndY","markerTypeCalculatorWithExtent","markerType","data","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","stacked","calcDataDim","getCalculationInfo","value","numCalculate","dataIndex","indicesOfNearest","get","coordArrValue","precision","getPrecision","Math","min","toFixed","markerTypeCalculator","max","average","median","dataTransform","seriesModel","getData","coordSys","coordinateSystem","dims","dimensions","coord","axisInfo","getAxisInfo","type","baseAxis","valueAxis","dim","coordInfo","baseDataDim","valueDataDim","xAxis","radiusAxis","yAxis","angleAxis","i","mapDimension","ret","valueIndex","valueDim","getDimension","getAxis","dataDimToCoordDim","getOtherAxis","getBaseAxis","dataDim","dimItem","getDimensionInfo","coordDim","dataFilter","containData","zoneFilter","item1","item2","containZone","createMarkerDimValueGetter","inCoordSys","dimName","dimIndex","rawVal","sum_1","count_1","each","val","idx","getMedian","getDataExtent"],"mappings":"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","sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport * as numberUtil from '../../util/number.js';\r\nimport { isDimensionStacked } from '../../data/helper/dataStackHelper.js';\r\nimport { indexOf, curry, clone, isArray } from 'zrender/lib/core/util.js';\r\nimport { parseDataValue } from '../../data/helper/dataValueHelper.js';\r\n\r\nfunction hasXOrY(item) {\r\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\r\n}\r\n\r\nfunction hasXAndY(item) {\r\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\r\n}\r\n\r\nfunction markerTypeCalculatorWithExtent(markerType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\r\n  var coordArr = [];\r\n  var stacked = isDimensionStacked(data, targetDataDim\r\n  /* , otherDataDim */\r\n  );\r\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\r\n  var value = numCalculate(data, calcDataDim, markerType);\r\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\r\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\r\n  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);\r\n  var coordArrValue = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.\r\n\r\n  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));\r\n  precision = Math.min(precision, 20);\r\n\r\n  if (precision >= 0) {\r\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\r\n  }\r\n\r\n  return [coordArr, coordArrValue];\r\n} // TODO Specified percent\r\n\r\n\r\nvar markerTypeCalculator = {\r\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\r\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\r\n  average: curry(markerTypeCalculatorWithExtent, 'average'),\r\n  median: curry(markerTypeCalculatorWithExtent, 'median')\r\n};\r\n/**\r\n * Transform markPoint data item to format used in List by do the following\r\n * 1. Calculate statistic like `max`, `min`, `average`\r\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\r\n */\r\n\r\nexport function dataTransform(seriesModel, item) {\r\n  if (!item) {\r\n    return;\r\n  }\r\n\r\n  var data = seriesModel.getData();\r\n  var coordSys = seriesModel.coordinateSystem;\r\n  var dims = coordSys && coordSys.dimensions; // 1. If not specify the position with pixel directly\r\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\r\n  // `yAxis` to specify the coord on each dimension\r\n  // parseFloat first because item.x and item.y can be percent string like '20%'\r\n\r\n  if (!hasXAndY(item) && !isArray(item.coord) && isArray(dims)) {\r\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\r\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\r\n\r\n    item = clone(item);\r\n\r\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\r\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\r\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\r\n      var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);\r\n      item.coord = coordInfo[0]; // Force to use the value of calculated value.\r\n      // let item use the value without stack.\r\n\r\n      item.value = coordInfo[1];\r\n    } else {\r\n      // FIXME Only has one of xAxis and yAxis.\r\n      item.coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];\r\n    }\r\n  } // x y is provided\r\n\r\n\r\n  if (item.coord == null || !isArray(dims)) {\r\n    item.coord = [];\r\n  } else {\r\n    // Each coord support max, min, average\r\n    var coord = item.coord;\r\n\r\n    for (var i = 0; i < 2; i++) {\r\n      if (markerTypeCalculator[coord[i]]) {\r\n        coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return item;\r\n}\r\nexport function getAxisInfo(item, data, coordSys, seriesModel) {\r\n  var ret = {};\r\n\r\n  if (item.valueIndex != null || item.valueDim != null) {\r\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\r\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\r\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\r\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\r\n  } else {\r\n    ret.baseAxis = seriesModel.getBaseAxis();\r\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\r\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\r\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\nfunction dataDimToCoordDim(seriesModel, dataDim) {\r\n  var dimItem = seriesModel.getData().getDimensionInfo(dataDim);\r\n  return dimItem && dimItem.coordDim;\r\n}\r\n/**\r\n * Filter data which is out of coordinateSystem range\r\n * [dataFilter description]\r\n */\r\n\r\n\r\nexport function dataFilter( // Currently only polar and cartesian has containData.\r\ncoordSys, item) {\r\n  // Always return true if there is no coordSys\r\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\r\n}\r\nexport function zoneFilter( // Currently only polar and cartesian has containData.\r\ncoordSys, item1, item2) {\r\n  // Always return true if there is no coordSys\r\n  return coordSys && coordSys.containZone && item1.coord && item2.coord && !hasXOrY(item1) && !hasXOrY(item2) ? coordSys.containZone(item1.coord, item2.coord) : true;\r\n}\r\nexport function createMarkerDimValueGetter(inCoordSys, dims) {\r\n  return inCoordSys ? function (item, dimName, dataIndex, dimIndex) {\r\n    var rawVal = dimIndex < 2 // x, y, radius, angle\r\n    ? item.coord && item.coord[dimIndex] : item.value;\r\n    return parseDataValue(rawVal, dims[dimIndex]);\r\n  } : function (item, dimName, dataIndex, dimIndex) {\r\n    return parseDataValue(item.value, dims[dimIndex]);\r\n  };\r\n}\r\nexport function numCalculate(data, valueDataDim, type) {\r\n  if (type === 'average') {\r\n    var sum_1 = 0;\r\n    var count_1 = 0;\r\n    data.each(valueDataDim, function (val, idx) {\r\n      if (!isNaN(val)) {\r\n        sum_1 += val;\r\n        count_1++;\r\n      }\r\n    });\r\n    return sum_1 / count_1;\r\n  } else if (type === 'median') {\r\n    return data.getMedian(valueDataDim);\r\n  } else {\r\n    // max & min\r\n    return data.getDataExtent(valueDataDim)[type === 'max' ? 1 : 0];\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}